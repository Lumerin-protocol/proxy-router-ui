name: Deploy Marketplace to Hosted Environment

on:
  workflow_dispatch:

  push:
    branches:
      - main
      - stg
      - dev
      - cicd/*

    paths: [".github/**", "src/**", "public/**", "package.json", "yarn.lock", "vite.config.ts", "tsconfig.json", "index.html", "LICENSE", "README.md"]

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

permissions:
  id-token: write   # Required for OIDC
  contents: write   # Required for creating releases and tags

env:
  SERVICE_NAME: marketplace

jobs:
  generate-tag:
    runs-on: ubuntu-latest
    name: ðŸ“¦ Generate Tag
    outputs:
      tag_name: ${{ steps.gen_tag_name.outputs.tag_name }}
      vtag: ${{ steps.gen_tag_name.outputs.vtag }}
      vfull: ${{ steps.gen_tag_name.outputs.vfull }}
      environment: ${{ steps.determine_env.outputs.environment }}
      should_create_release: ${{ steps.determine_env.outputs.should_create_release }}
    steps:
      - name: Clone repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Determine environment
        id: determine_env
        run: |
          BRANCH="${{ github.ref_name }}"
          if [ "$BRANCH" == "main" ]; then
            ENV="main"
            CREATE_RELEASE="true"
          elif [ "$BRANCH" == "stg" ]; then
            ENV="stg"
            CREATE_RELEASE="false"
          elif [[ "$BRANCH" == cicd/* ]]; then
            ENV="dev"
            CREATE_RELEASE="false"
            echo "ðŸ”§ CI/CD feature branch detected - deploying to DEV"
          else
            ENV="dev"
            CREATE_RELEASE="false"
          fi
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "should_create_release=${CREATE_RELEASE}" >> $GITHUB_OUTPUT

      - name: Determine tag name
        id: gen_tag_name
        shell: bash
        run: |
          VMAJ_NEW=2
          VMIN_NEW=0
          VPAT_NEW=0
          set +o pipefail
          VLAST=$(git describe --tags --abbrev=0 --match='v[1-9]*' refs/remotes/origin/main 2>/dev/null | cut -c2-)

          if [ -n "$VLAST" ]; then
              eval $(echo "$VLAST" | awk -F '.' '{print "VMAJ="$1" VMIN="$2" VPAT="$3}')
          else
              VMAJ=0
              VMIN=0
              VPAT=0
          fi
          
          if [ "$GITHUB_REF_NAME" = "main" ]; then
              if [ "$VMAJ_NEW" -gt "$VMAJ" ]; then
                  VMAJ=$VMAJ_NEW
                  VMIN=$VMIN_NEW
                  VPAT=$VPAT_NEW
              else
                  VMIN=$((VMIN+1))
                  VPAT=0
              fi
              VFULL=${VMAJ}.${VMIN}.${VPAT}
              VTAG=v$VFULL
          else
              MB=$(git merge-base refs/remotes/origin/main HEAD)
              VPAT=$(git rev-list --count --no-merges ${MB}..HEAD)
              VFULL=${VMAJ}.${VMIN}.${VPAT}
              RNAME=${GITHUB_REF_NAME##*/}
              [ "$GITHUB_EVENT_NAME" = "pull_request" ] && RNAME=pr${GITHUB_REF_NAME%/merge}
              VTAG=v${VFULL}-${RNAME}
          fi

          # Output variables for use in subsequent jobs environment
          echo "tag_name=${VTAG}" >> $GITHUB_OUTPUT
          echo "vtag=${VTAG}" >> $GITHUB_OUTPUT
          echo "vfull=${VFULL}" >> $GITHUB_OUTPUT
          echo "âœ… Proposed Tag: $VTAG (will be created after successful deployment)" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“‹ Last Production Tag: $VLAST"  >> $GITHUB_STEP_SUMMARY

  setup:
    name: âš™ï¸ Setup
    needs:
      - generate-tag
    runs-on: ubuntu-latest
    # NO environment scope - uses repo-level AWS_ROLE_ARN secrets
    outputs:
      environment: ${{ needs.generate-tag.outputs.environment }}
      s3_bucket: ${{ steps.get_deployment_config.outputs.s3_bucket }}
      cloudfront_distribution: ${{ steps.get_deployment_config.outputs.cloudfront_distribution_id }}
      aws_region: ${{ steps.get_deployment_config.outputs.aws_region }}
      marketplace_url: ${{ steps.get_deployment_config.outputs.marketplace_url }}
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.generate-tag.outputs.environment == 'dev' && secrets.AWS_ROLE_ARN_DEV || needs.generate-tag.outputs.environment == 'stg' && secrets.AWS_ROLE_ARN_STG || secrets.AWS_ROLE_ARN_LMN }}
          aws-region: us-east-1
          role-session-name: GitHubActions-Marketplace-Setup-${{ github.run_id }}

      - name: Get deployment configuration from AWS Secrets Manager
        id: get_deployment_config
        run: |
          ENV="${{ needs.generate-tag.outputs.environment }}"
          
          # Map environment to AWS secret suffix
          case $ENV in
            dev)
              SECRET_NAME="futures-marketplace-secrets-v2-dev"
              ;;
            stg)
              SECRET_NAME="futures-marketplace-secrets-v2-stg"
              ;;
            main)
              SECRET_NAME="futures-marketplace-secrets-v2-lmn"
              ;;
          esac
          
          echo "ðŸ“¦ Retrieving deployment config from AWS Secrets Manager: ${SECRET_NAME}"
          
          # Retrieve the secret
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id ${SECRET_NAME} \
            --query SecretString \
            --output text)
          
          # Parse deployment configuration
          S3_BUCKET=$(echo $SECRET_JSON | jq -r '.deployment.s3_bucket')
          CF_DISTRO=$(echo $SECRET_JSON | jq -r '.deployment.cloudfront_distribution_id')
          MARKETPLACE_URL=$(echo $SECRET_JSON | jq -r '.deployment.marketplace_url')
          AWS_REGION=$(echo $SECRET_JSON | jq -r '.deployment.aws_region')
          
          # Output for use in subsequent jobs
          echo "s3_bucket=${S3_BUCKET}" >> $GITHUB_OUTPUT
          echo "cloudfront_distribution_id=${CF_DISTRO}" >> $GITHUB_OUTPUT
          echo "marketplace_url=${MARKETPLACE_URL}" >> $GITHUB_OUTPUT
          echo "aws_region=${AWS_REGION}" >> $GITHUB_OUTPUT
          
          echo "âœ… Deployment Configuration:"
          echo "   S3 Bucket: ${S3_BUCKET}"
          echo "   CloudFront: ${CF_DISTRO}"
          echo "   URL: ${MARKETPLACE_URL}"
          echo "   Region: ${AWS_REGION}"

  build:
    name: ðŸ”¨ Build
    needs:
      - generate-tag
      - setup
    runs-on: ubuntu-latest
    # HAS environment scope - can access environment-scoped secrets/variables
    environment:
      name: ${{ needs.generate-tag.outputs.environment == 'main' && 'prd' || needs.generate-tag.outputs.environment }}
      url: ${{ needs.setup.outputs.marketplace_url }}
    outputs:
      version: ${{ needs.generate-tag.outputs.vtag }}
      environment: ${{ needs.setup.outputs.environment }}
      s3_bucket: ${{ needs.setup.outputs.s3_bucket }}
      cloudfront_distribution: ${{ needs.setup.outputs.cloudfront_distribution }}
      aws_region: ${{ needs.setup.outputs.aws_region }}
      marketplace_url: ${{ needs.setup.outputs.marketplace_url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'yarn'

      - name: Create .env file
        id: create_env
        run: |
          ENV="${{ needs.generate-tag.outputs.environment }}"
          VERSION="${{ needs.generate-tag.outputs.vtag }}"
          
          echo "ðŸ”§ Creating .env file for ${ENV} environment"
          echo "ðŸ“Œ Version tag: ${VERSION}"
          
          # Create .env file with environment-scoped variables
          # GitHub Environments automatically scope secrets/vars to the environment
          cat > .env << EOF
          REACT_APP_BUY_LMR_URL=${{ secrets.REACT_APP_BUY_LMR_URL || vars.REACT_APP_BUY_LMR_URL }}
          REACT_APP_CHAIN_ID=${{ secrets.REACT_APP_CHAIN_ID || vars.REACT_APP_CHAIN_ID }}
          REACT_APP_CLONE_FACTORY=${{ secrets.REACT_APP_CLONE_FACTORY || vars.REACT_APP_CLONE_FACTORY }}
          REACT_APP_ETHERSCAN_URL=${{ secrets.REACT_APP_ETHERSCAN_URL || vars.REACT_APP_ETHERSCAN_URL }}
          REACT_APP_GITBOOK_URL=${{ secrets.REACT_APP_GITBOOK_URL || vars.REACT_APP_GITBOOK_URL }}
          REACT_APP_INDEXER_URL=${{ secrets.REACT_APP_INDEXER_URL || vars.REACT_APP_INDEXER_URL }}
          REACT_APP_MULTICALL_ADDRESS=${{ secrets.REACT_APP_MULTICALL_ADDRESS || vars.REACT_APP_MULTICALL_ADDRESS }}
          REACT_APP_PAYMENT_SLIPPAGE_PERCENT=${{ secrets.REACT_APP_PAYMENT_SLIPPAGE_PERCENT || vars.REACT_APP_PAYMENT_SLIPPAGE_PERCENT || '1' }}
          REACT_APP_READ_ONLY_ETH_NODE_URL=${{ secrets.REACT_APP_READ_ONLY_ETH_NODE_URL }}
          REACT_APP_TITAN_LIGHTNING_POOL=${{ secrets.REACT_APP_TITAN_LIGHTNING_POOL || vars.REACT_APP_TITAN_LIGHTNING_POOL || 'pplp.titan.io:4141' }}
          REACT_APP_URL=${{ needs.setup.outputs.marketplace_url }}
          REACT_APP_VALIDATOR_REGISTRY_ADDRESS=${{ secrets.REACT_APP_VALIDATOR_REGISTRY_ADDRESS || vars.REACT_APP_VALIDATOR_REGISTRY_ADDRESS }}
          REACT_APP_VERSION=${{ needs.generate-tag.outputs.vtag }}
          REACT_APP_WALLET_CONNECT_ID=${{ secrets.REACT_APP_WALLET_CONNECT_ID }}
          DEV_SERVER_HTTPS=false
          REACT_APP_FUTURES_TOKEN_ADDRESS=${{ secrets.REACT_APP_FUTURES_TOKEN_ADDRESS || vars.REACT_APP_FUTURES_TOKEN_ADDRESS }}
          REACT_APP_FUTURES_REQUIRED_LMR=${{ secrets.REACT_APP_FUTURES_REQUIRED_LMR || vars.REACT_APP_FUTURES_REQUIRED_LMR || '10000' }}
          REACT_APP_SUBGRAPH_FUTURES_URL=${{ secrets.REACT_APP_SUBGRAPH_FUTURES_URL || vars.REACT_APP_SUBGRAPH_FUTURES_URL }}
          EOF
          
          echo "âœ… .env file created"
          echo "ðŸ“„ Version in .env: $(grep REACT_APP_VERSION .env)"
          echo "ðŸ“„ .env contents (sanitized):"
          cat .env | sed 's/=.*/=***/'

      - name: Install dependencies
        run: |
          echo "ðŸ“¦ Installing dependencies..."
          yarn install --frozen-lockfile

      - name: Build application
        run: |
          echo "ðŸ—ï¸ Building application..."
          yarn build
          
          echo "âœ… Build complete"
          ls -lh build/

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ needs.generate-tag.outputs.environment }}
          path: build/
          retention-days: 1

  deploy:
    name: ðŸš€ Deploy
    runs-on: ubuntu-latest
    needs: [generate-tag, setup, build]
    
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-${{ needs.generate-tag.outputs.environment }}
          path: build/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.generate-tag.outputs.environment == 'dev' && secrets.AWS_ROLE_ARN_DEV || needs.generate-tag.outputs.environment == 'stg' && secrets.AWS_ROLE_ARN_STG || secrets.AWS_ROLE_ARN_LMN }}
          aws-region: ${{ needs.setup.outputs.aws_region }}
          role-session-name: GitHubActions-Marketplace-Deploy-${{ github.run_id }}

      - name: Deploy to S3
        run: |
          echo "ðŸš€ Deploying to S3 bucket: ${{ needs.setup.outputs.s3_bucket }}"
          aws s3 sync build/ s3://${{ needs.setup.outputs.s3_bucket }}/ --delete
          
          echo "âœ… Files uploaded to S3"

      - name: Invalidate CloudFront cache
        run: |
          echo "ðŸ”„ Invalidating CloudFront distribution: ${{ needs.setup.outputs.cloudfront_distribution }}"
          aws cloudfront create-invalidation \
            --distribution-id ${{ needs.setup.outputs.cloudfront_distribution }} \
            --paths "/*"
          
          echo "âœ… CloudFront cache invalidated"

  verify:
    name: ðŸ” Verify
    runs-on: ubuntu-latest
    needs: [generate-tag, setup, build, deploy]
    
    steps:
      - name: Wait for CloudFront propagation
        run: |
          echo "â³ Waiting for CloudFront to propagate changes..."
          echo "   CloudFront invalidations typically take 1-5 minutes"
          echo "   Waiting 90 seconds for initial propagation..."
          sleep 90
          echo "âœ… Wait complete, proceeding to verification"

      - name: Verify deployment and version
        run: |
          URL="${{ needs.setup.outputs.marketplace_url }}"
          EXPECTED_VERSION="${{ needs.generate-tag.outputs.vtag }}"
          
          echo "ðŸ§ª Verifying deployment at $URL"
          echo "ðŸ“Œ Expected version: $EXPECTED_VERSION"
          
          # Fetch the page
          HTTP_CODE=$(curl -o /tmp/page.html -s -w "%{http_code}" "$URL")
          
          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "âŒ Marketplace returned HTTP $HTTP_CODE"
            echo "::error::Marketplace not accessible (HTTP $HTTP_CODE)"
            exit 1
          fi
          
          echo "âœ… Marketplace is accessible (HTTP $HTTP_CODE)"
          
          # Extract version from meta tag
          ACTUAL_VERSION=$(grep -oP '<meta name="application-version" content="\K[^"]+' /tmp/page.html || echo "")
          
          if [ -z "$ACTUAL_VERSION" ]; then
            echo "âš ï¸ WARNING: Could not extract version from page"
            echo "::warning::Version meta tag not found on deployed page"
            echo "ðŸ“„ HTML head section:"
            grep -A 10 "<head>" /tmp/page.html || echo "Could not extract head section"
          elif [ "$ACTUAL_VERSION" = "$EXPECTED_VERSION" ]; then
            echo "âœ… Version matches! Deployed: $ACTUAL_VERSION"
            echo "::notice::Deployment verified successfully with version $ACTUAL_VERSION"
          else
            echo "âš ï¸ WARNING: Version mismatch!"
            echo "   Expected: $EXPECTED_VERSION"
            echo "   Actual:   $ACTUAL_VERSION"
            echo "::warning::Deployed version ($ACTUAL_VERSION) does not match expected version ($EXPECTED_VERSION)"
          fi

  summary:
    name: ðŸ“Š Summary & Tag
    runs-on: ubuntu-latest
    needs: [generate-tag, setup, build, deploy, verify]
    if: always()
    
    steps:
      - name: Clone repository
        if: needs.verify.result == 'success'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        if: needs.verify.result == 'success'
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create and push tag
        if: needs.verify.result == 'success'
        run: |
          TAG_NAME=${{ needs.generate-tag.outputs.tag_name }}
          echo "ðŸ·ï¸ Creating tag after successful deployment: $TAG_NAME"
          
          # Check if tag already exists
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "âš ï¸ Tag $TAG_NAME already exists, skipping tag creation"
          else
            git tag -a "$TAG_NAME" -m "Release $TAG_NAME - Deployed to ${{ needs.generate-tag.outputs.environment }}"
            git push origin "$TAG_NAME"
            echo "âœ… Tag $TAG_NAME created and pushed"
          fi

      - name: Create GitHub Release
        if: needs.verify.result == 'success' && needs.generate-tag.outputs.should_create_release == 'true'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.generate-tag.outputs.tag_name }}
          release_name: Marketplace ${{ needs.generate-tag.outputs.tag_name }}
          body: |
            ## Marketplace Release ${{ needs.generate-tag.outputs.tag_name }}
            
            **Environment:** Production
            **Branch:** ${{ github.ref_name }}
            **Commit:** ${{ github.sha }}
            **Deployed:** ${{ needs.setup.outputs.marketplace_url }}
            
            ### Changes
            This production release includes the latest changes from the main branch.
          draft: false
          prerelease: false

      - name: Deployment summary
        if: needs.verify.result == 'success'
        run: |
          echo "## ðŸŽ‰ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Service:** Marketplace" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.generate-tag.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.generate-tag.outputs.vtag }}" >> $GITHUB_STEP_SUMMARY
          echo "**URL:** ${{ needs.setup.outputs.marketplace_url }}" >> $GITHUB_STEP_SUMMARY
          echo "**S3 Bucket:** ${{ needs.setup.outputs.s3_bucket }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Marketplace deployed and verified successfully" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ·ï¸ Git tag created: ${{ needs.generate-tag.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.generate-tag.outputs.should_create_release }}" == "true" ]; then
            echo "ðŸ“¦ GitHub Release created for production deployment" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Failure summary
        if: needs.verify.result != 'success'
        run: |
          echo "## âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Service:** Marketplace" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.generate-tag.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.generate-tag.outputs.vtag }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ Deployment or verification failed. Check logs above for details." >> $GITHUB_STEP_SUMMARY
          echo "ðŸš« Tag NOT created - deployment was not successful" >> $GITHUB_STEP_SUMMARY

